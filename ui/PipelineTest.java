
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

import org.opencv.core.*;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;

/**
* Pipeline class.
*
* <P>Autogenerated pipeline from GRIP.
*
* <P>Make sure to set all sources using the setters before running processImage().
*
* <P>Tutorials and examples can be found online
*
* @author GRIP
*/
public class Pipeline{

	//This map links the Outputs with their names
	protected Map<String,Object> outputs;
	protected Mat source0;
	protected Mat source1;

	/**
	 * This constructor sets up the pipeline
	 */
	public Pipeline(){
		outputs = new HashMap<String,Object>();
	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	public void processImage(){
	    //Step0: Blur:
            //input
            Mat input0 = source0;
            BlurType type0 = BlurType.get("Box Blur");
            double radius0 = 1.8018018018018014;
            //output
            Mat output0 = new Mat();
            Blur(input0, type0, radius0, output0);
            outputs.put("output0", output0);

	    //Step1: HSV_Threshold:
            //input
            Mat input1 = output0;
            double[] hue1 = {42.086330935251794, 91.37521222410867};
            double[] saturation1 = {41.276978417266186, 196.553480475382};
            double[] value1 = {50.44964028776978, 135.9422750424448};
            //output
            Mat output1 = new Mat();
            HSV_Threshold(input1, hue1, saturation1, value1, output1);
            outputs.put("output1", output1);

	    //Step2: CV_dilate:
            //input
            Mat src2 = source1;
            Mat kernel2 = null;
            Point anchor2 = null;
            int iterations2 = 1;
            Integer bordertype2 = Core.BORDER_CONSTANT;
            Scalar bordervalue2 = null;
            //output
            Mat output2 = new Mat();
            CV_dilate(src2, kernel2, anchor2, iterations2, bordertype2, bordervalue2, output2);
            outputs.put("output2", output2);

}
      /**
      * This method is a generated setter for source0.
      * @param source is the Mat that the source will be set to
      */
      public void setsource0(Mat source0){
      	 this.source0 = source0;
      }
      /**
      * This method is a generated setter for source1.
      * @param source is the Mat that the source will be set to
      */
      public void setsource1(Mat source1){
      	 this.source1 = source1;
      }
    	/**
    	 * This method is a generated getter for the output of a Blur.
    	 * @return Mat is the output.
    	 */
    	public Mat getoutput0(){
    		return (Mat) outputs.get("output0");
    	}
    	/**
    	 * This method is a generated getter for the output of a HSV_Threshold.
    	 * @return Mat is the output.
    	 */
    	public Mat getoutput1(){
    		return (Mat) outputs.get("output1");
    	}
    	/**
    	 * This method is a generated getter for the output of a CV_dilate.
    	 * @return Mat is the output.
    	 */
    	public Mat getoutput2(){
    		return (Mat) outputs.get("output2");
    	}

enum BlurType{
	BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"), BILATERAL_FILTER("Bilateral Filter");

	private final String label;

	BlurType(String label) {
		this.label = label;
	}

	public static BlurType get(String type){
	    if(BILATERAL_FILTER.label.equals(type)){
	        return BILATERAL_FILTER;
	    }
	    else if(GAUSSIAN.label.equals(type)){
	        return GAUSSIAN;
	    }
	    else if(MEDIAN.label.equals(type)){
        	return MEDIAN;
        }
        else{
        return BOX;
        }

	}

	@Override
	public String toString() {
		return this.label;
	}
}

void Blur(Mat input, BlurType type, double doubleRadius, Mat output){
    int radius = (int) doubleRadius;
	int kernalSize;
	switch(type){
 		case BOX:
 			kernalSize = 2*radius+1;
 			Imgproc.blur(input,output,new Size(kernalSize, kernalSize));
 			break;
		case GAUSSIAN:
			kernalSize = 6*radius +1;
			Imgproc.GaussianBlur(input,output, new Size(kernalSize, kernalSize),radius);
			break;
		case MEDIAN: 
			kernalSize = 2*radius +1;
			Imgproc.medianBlur(input,output,kernalSize);
			break;
		case BILATERAL_FILTER:
			Imgproc.bilateralFilter(input,output,-1,radius,radius);
			break;
	}
}

    void HSV_Threshold(Mat input, double[] hue, double[] sat, double[] val, Mat out){
		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
		Core.inRange(out, new Scalar(hue[0], sat[0] ,val[0]), new Scalar(hue[1], sat[1] ,val[1]), out);
	}
void CV_dilate(Mat src, Mat kernal, Point anchor, int iterations,int borderType, Scalar borderValue, Mat dst){
	if(kernal == null){
		kernal = new Mat();
	}
	if(anchor == null){
		anchor = new Point(-1,-1);
	}
	Imgproc.dilate(src, kernal, dst, anchor, iterations, borderType, borderValue);
}


}
